import numpy as npdef binning(filename,box_depth):    """分箱"""    datas = np.loadtxt('data1.txt')    box_dict = {}    box_num = int(len(datas) / box_depth)    if int(len(datas) % box_depth)!=0:        box_num = box_num+1     #不能整除时余下的也要占用一个箱    for i in range(0, box_num):        box_dict["箱子" + str(i)] = []  # 创建一定数量的空箱子用来装填数据    while box_num*box_depth > len(datas):        datas = np.append(datas, datas[-1])     #补足数据    return datas,box_dict,box_num,box_depthdef box_mean_smooth(datas,box_dict,box_num,box_depth):    for n in range(0, len(datas), box_depth):        mean = round(sum(datas[n:n + box_depth]) / box_depth, 2)  # 每box_depth个数计算平均值，保留一位小数        for m in range(0, box_depth):            box_dict["箱子" + str(int(n / box_depth))].append(mean)  # 将光滑后的均值填入每个箱中    return box_dictdef box_mid_smooth(datas,box_dict,box_num,box_depth):    for n in range(0, len(datas), box_depth):        mid = np.median(datas[n:n + box_depth])        for m in range(0, box_depth):            box_dict["箱子" + str(int(n / box_depth))].append(mid)  # 将光滑后的中值填入每个箱中    return box_dictdef box_boundary_smooth(datas,box_dict,box_num,box_depth):    i = 0    for n in range(0, len(datas), box_depth):        for m in range(0, box_depth):            left = datas[i]            right = datas[i + box_depth - 1]            if (abs(datas[n] - left) - abs(datas[n] - right)) <= 0:                box_dict["箱子" + str(int(n / box_depth))].append(left)  # 将光滑后的边界值填入每个箱中            else:                box_dict["箱子" + str(int(n / box_depth))].append(right)        i = i + box_depth    return box_dictfilename='data1.txt'box_depth=5 #箱的深度datas,box_dict,box_num,box_depth=binning(filename,box_depth)print("均值平滑")print(box_mean_smooth(datas,box_dict,box_num,box_depth))       #均值平滑#print("中位数平滑")#print(box_mid_smooth(datas,box_dict,box_num,box_depth))        #中位数平滑#print("边界平滑")#print(box_boundary_smooth(datas,box_dict,box_num,box_depth))    #边界平滑